{
  "hash": "aa951378c6c025637808091e58db8e47",
  "result": {
    "markdown": "# Short intro to R\n\nIn Quarto documents like this one, we can write comments by just using plain text. In contrast, code needs to be within *code blocks*, like the one below. To execute a code block, you can click on the little \"Play\" button or press `Cmd/Ctrl + Shift + Enter` when your keyboard is hovering the code block.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nThat was our first R command, a simple math operation. Of course, we can also do more complex arithmetic:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n12345 ^ 2  / (200 + 25 - 6 * 2) # this is an inline comment, see the leading \"#\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 715488.4\n```\n:::\n:::\n\n\nIn order to *create* a code block, you can press `Cmd/Ctrl + Alt + i` or click on the little green \"+C\" icon on top of the script.\n\n::: {.callout-tip}\n\n## Exercise\n\nCreate your own code block below and run a math operation.\n\n:::\n\n## Objects\n\nA huge part of R is working with *objects*. Let's see how they work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_object <- 10 # opt/alt + minus sign will make the arrow \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_object # to print the value of an object, just call its name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nWe can now use this object in our operations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 ^ my_object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1024\n```\n:::\n:::\n\n\nOr even create another object out of it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_object2 <- my_object * 2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_object2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\nYou can delete objects with the `rm()` function (for \"remove\"):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(my_object2)\n```\n:::\n\n\n## Vectors and functions \n\nObjects can be of different types. One of the most useful ones is the *vector*, which holds a series of values. To create one manually, we can use the `c()` function (for \"combine\"):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(6, -11, my_object, 0, 20)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   6 -11  10   0  20\n```\n:::\n:::\n\n\nWe can use square brackets to retrieve parts of vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector[4] # fourth element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector[1:2] # first two elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   6 -11\n```\n:::\n:::\n\n\nLet's check out some basic functions we can use with numbers and numeric vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(my_object) # squared root\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.162278\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(my_object) # logarithm (natural by default)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.302585\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(my_vector) # standard deviation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11.53256\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(my_vector) # minimum value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -11\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(my_vector) # maximum value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(my_vector) # length (number of elements)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nNotice that if we wanted to save any of these results for later, we would need to *assign* them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean <- mean(my_vector)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nThese functions are quite simple: they take one object and do one operation. A lot of functions are a bit more complex---they take multiple objects or take options. For example, see the `sort()` function, which by default sorts a vector *increasingly*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -11   0   6  10  20\n```\n:::\n:::\n\n\nIf we instead want to sort our vector *decreasingly*, we can use the `decreasing = TRUE` argument (`T` also works as an abbreviation for `TRUE`).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(my_vector, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  20  10   6   0 -11\n```\n:::\n:::\n\n\n::: {.callout-tip}\n\nIf you use the argument values in order, you can avoid writing the argument names (see below). This is sometimes useful, but can also lead to confusing code---use it with caution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(my_vector, T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  20  10   6   0 -11\n```\n:::\n:::\n\n\n:::\n\nTo check the arguments of a function, you can examine its help file: look the function up on the \"Help\" panel on RStudio or use a command like the following: `?sort`.\n\n::: {.callout-tip}\n\n## Exercise\n\nExamine the help file of the `log()` function. How can we compute the the base-10 logarithm of `my_object`? Your code:\n\n:::\n\nOther than numeric vectors, character vectors are also useful:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_character_vector <- c(\"Apple\", \"Orange\", \"Watermelon\", \"Banana\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_character_vector[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Watermelon\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(my_character_vector) # count number of characters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5  6 10  6\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Data frames and lists\n\nAnother useful object type is the *data frame*. Data frames can store multiple vectors in a tabular format. We can manually create one with the `data.frame()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame <- data.frame(fruit = my_character_vector,\n                            calories_per_100g = c(52, 47, 30, 89),\n                            water_per_100g = c(85.6, 86.8, 91.4, 74.9))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       fruit calories_per_100g water_per_100g\n1      Apple                52           85.6\n2     Orange                47           86.8\n3 Watermelon                30           91.4\n4     Banana                89           74.9\n```\n:::\n:::\n\n\nNow we have a little 4x3 data frame of fruits with their calorie counts and water composition. We gathered the nutritional information from the [USDA (2019)](https://fdc.nal.usda.gov/).\n\nWe can use the `data_frame$column` construct to access the vectors within the data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(my_data_frame$calories_per_100g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54.5\n```\n:::\n:::\n\n\n::: {.callout-tip}\n\n## Exercise\n\nObtain the maximum value of water content per 100g in the data. Your code:\n\n:::\n\nWe will learn much more about data frames in our next module on data analysis. \n\nAfter talking about vectors and data frames, the last object type that we will cover is the *list*. Lists are super flexible objects that can contain just about anything:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(my_object, my_vector, my_data_frame)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 10\n\n[[2]]\n[1]   6 -11  10   0  20\n\n[[3]]\n       fruit calories_per_100g water_per_100g\n1      Apple                52           85.6\n2     Orange                47           86.8\n3 Watermelon                30           91.4\n4     Banana                89           74.9\n```\n:::\n:::\n\n\nTo retrieve the elements of a list, we need to use double square brackets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nLists are sometimes useful due to their flexibility, but are much less common in routine data analysis compared to vectors or data frames.\n\n## Packages\n\nThe R community has developed thousands of *packages*, which are specialized collections of functions, datasets, and other resources. To install one, you should use the `install.packages()` command. Below we will install the `tidyverse` package, a suite for data analysis that we will use in the next modules. You just need to install packages once, and then they will be available system-wide.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\") # this can take a couple of minutes\n```\n:::\n\n\nIf you want to use an installed package in your script, you must load it with the `library()` function. Some packages, as shown below, will print descriptive messages once loaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n::: {.callout-warning}\nRemember that `install.packages(\"package\")` needs to be executed just once, while `library(package)` needs to be in each script in which you plan to use the package. In general, never include `install.packages(\"package\")` as part of your scripts or Quarto documents!\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}