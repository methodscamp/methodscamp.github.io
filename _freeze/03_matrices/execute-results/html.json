{
  "hash": "ae364df220d064cab380da40a8e8b923",
  "result": {
    "markdown": "# Matrices\n\n## Introduction\n\n### Scalars\n\n-   One number (for example, 12) is referred to as a scalar.\n\n-   Each scalar in a matrix is an *element* of that matrix.\n\n$$\\begin{bmatrix}\n12\n\\end{bmatrix}$$\n\n::: callout-note\nThis is also called a 1 x 1 (\"one by one\") matrix.\n:::\n\n### Vectors\n\n-   We can put several scalars together to make a vector.\n\n-   Here is an example: $$\\begin{bmatrix}\n        12 \\\\\n        14 \\\\\n        15\n        \\end{bmatrix}\n        = b$$\n\n-   Since this is a column of numbers, we cleverly refer to it as a *column vector*.\n\n-   Here is another example of a vector: $$\\begin{bmatrix}\n    12 & 14 & 15\n    \\end{bmatrix}\n    = d$$\n\n-   This, in contrast, is called a *row vector*.\n\n#### Vector construction in RStudio\n\n-   Vectors are very easy to construct in RStudio.\n-   Here are two examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making a simple column vector\ncol_vector <- matrix(1:12)\ncol_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n[11,]   11\n[12,]   12\n```\n:::\n\n```{.r .cell-code}\n# Making a simple row vector\nrow_vector <- 15:23\nrow_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15 16 17 18 19 20 21 22 23\n```\n:::\n:::\n\n\n## Operators\n\n### Summation\n\n-   The summation operator $\\sum$ lets us perform an operation on a sequence of numbers, which is often but not always a vector.\n\n$$x = \\begin{bmatrix}\n12 & 7 & -2 & 0 & 1\n\\end{bmatrix}$$\n\n-   We can then calculate the sum of the first three elements of the vector, which is expressed as follows: $$\\sum_{i=1}^3 x_i$$\n\n-   Then, we do the following math: $$12+7+(-2)=17$$\n\n### Product\n\n-   The product operator $\\prod$ can also perform operations over a sequence of elements in a vector.\n\n$$z = \\begin{bmatrix}\n5 & -3 & 5 & 1\n\\end{bmatrix}$$\n\n-   We can then calculate the calculate the product of the four elements in the vector, which is expressed as follows: $$\\prod_{i=1}^4 z_i$$\n\n-   Then, we do the following math: $$5 \\times -3 \\times 5 \\times 1=-75$$ \\## Matrices\n\n#### Operators in RStudio\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summation\nmat <- c(5,-3,5,1)\nsum(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n# Product\nprod(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -75\n```\n:::\n:::\n\n\n### Basics\n\n-   We can append vectors together to form a matrix:\n\n$$\\begin{bmatrix}\n12 & 14 & 15 \\\\\n115 & 22 & 127 \\\\\n193 & 29 & 219\n\\end{bmatrix}\n= A$$\n\n-   The number of rows and columns of a matrix constitute the dimensions of the matrix.\n\n-   The first number is the number of rows (\"r\") and the second number is the number of columns (\"c\") in the matrix.\n\n::: callout-important\nFind a way to remember \"r x c\" *permanently*. The order of the dimensions never changes.\n:::\n\n-   Matrix $A$ above, for example, is a $3x3$ matrix.\n\n-   We often use capital letters (sometimes **bold-faced**) to represent matrices.\n\n#### Appending in RStudio\n\n-   We use `rbind()` to create a matrix, in which each vector will be a row.\n-   If we use `cbind()`, then each vector will be a column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create some vectors\nvec_1 <- 1:4\nvec_2 <- 5:8\nvec_3 <- 9:12\nvec_4 <- 13:16\n\n# rbind\nrbind_mat <- rbind(vec_1, vec_2, vec_3, vec_4)\nrbind_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4]\nvec_1    1    2    3    4\nvec_2    5    6    7    8\nvec_3    9   10   11   12\nvec_4   13   14   15   16\n```\n:::\n\n```{.r .cell-code}\n# cbind\ncbind_mat <- cbind(vec_1, vec_2, vec_3, vec_4)\ncbind_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     vec_1 vec_2 vec_3 vec_4\n[1,]     1     5     9    13\n[2,]     2     6    10    14\n[3,]     3     7    11    15\n[4,]     4     8    12    16\n```\n:::\n:::\n\n\n### Structure\n\n-   How do we refer to specific elements of the matrix?\n\n-   Matrix $A$ is an $m\\times n$ matrix where $m=n=3$\n\n-   More generally, matrix $B$ is an $m\\times n$ matrix where the elements look like this: $$B=\n    \\begin{bmatrix}\n    b_{11} & b_{12} & b_{13} & \\ldots & b_{1n} \\\\\n    b_{21} & b_{22} & b_{23} & \\ldots & b_{2n} \\\\\n    \\vdots & \\vdots & \\vdots & \\ldots & \\vdots \\\\\n    b_{m1} & b_{m2} & b_{m3} & \\ldots & b_{mn}\n    \\end{bmatrix}$$\n\n-   Thus $b_{23}$ refers to the second unit down and third across.\n\n::: callout-tip\n## Reminder\n\nWhen trying to identify a specific element, the first subscript is the element's row and the second subscript is the element's column (*always* in that order).\n:::\n\n#### Constructing matrices in RStudio\n\n-   Matrices are very easy to construct in RStudio.\n-   The basic syntax is `matrix(data, nrow, ncol, byrow, dimnames)`.\n    -   `data` is the input vector which becomes the data elements of the matrix.\n    -   `nrow` is the number of rows to be created.\n    -   `ncol` is the number of columns to be created.\n    -   `byrow` is a logical clue. If TRUE then the input vector elements are arranged by row.\n    -   `dimname` is the names assigned to the rows and columns.\n-   Here are some examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Elements are arranged sequentially by row.\nM <- matrix(c(1:12), nrow = 4, byrow = TRUE)\nprint(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n```\n:::\n\n```{.r .cell-code}\n# Elements are arranged sequentially by column.\nN <- matrix(c(1:12), nrow = 4, byrow = FALSE)\nprint(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n:::\n\n```{.r .cell-code}\n# Define the column and row names.\nrownames = c(\"row1\", \"row2\", \"row3\", \"row4\")\ncolnames = c(\"col1\", \"col2\", \"col3\")\n\nP <- matrix(c(1:12), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))\n\nprint(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3\nrow1    1    2    3\nrow2    4    5    6\nrow3    7    8    9\nrow4   10   11   12\n```\n:::\n\n```{.r .cell-code}\n# Access the element at 1st row and 3rd column.\nprint(P[1,3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n# Access the element at 4th row and 2nd column.\nprint(P[4,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\n## Matrix operations\n\n### Addition and subtraction\n\n-   Addition and subtraction are straightforward operations.\n\n-   Matrices must have *exactly* the same dimensions for both of these operations.\n\n-   We add or subtract each element with the corresponding element from the other matrix.\n\n-   This is expressed as follows:\n\n$$A \\pm B=C$$\n\n$$c_{ij}=a_{ij} \\pm b_{ij} \\text{ }\\forall i,j$$\n\n$$\\begin{bmatrix}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\\\\\na_{31} & a_{32} & a_{33}\n\\end{bmatrix}\n\\pm\n\\begin{bmatrix}\nb_{11} & b_{12} & b_{13}\\\\\nb_{21} & b_{22} & b_{23}\\\\\nb_{31} & b_{32} & b_{33}\n\\end{bmatrix}$$ $$=$$ $$\\begin{bmatrix}\na_{11}\\pm b_{11} & a_{12}\\pm b_{12} & a_{13}\\pm b_{13}\\\\\na_{21}\\pm b_{21} & a_{22}\\pm b_{22} & a_{23}\\pm b_{23}\\\\\na_{31}\\pm b_{31} & a_{32}\\pm b_{32} & a_{33}\\pm b_{33}\n\\end{bmatrix}$$\n\n#### Add and subtract in RStudio\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create two 2x3 matrices.\nmatrix1 <- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)\nprint(matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    3   -1    2\n[2,]    9    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix2 <- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)\nprint(matrix2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    0    3\n[2,]    2    9    4\n```\n:::\n\n```{.r .cell-code}\n# Add the matrices.\nresult1 <- matrix1 + matrix2\ncat(\"Result of addition\",\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResult of addition \n```\n:::\n\n```{.r .cell-code}\nprint(result1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    8   -1    5\n[2,]   11   13   10\n```\n:::\n\n```{.r .cell-code}\n# Subtract the matrices\nresult2 <- matrix1 - matrix2\ncat(\"Result of subtraction\",\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResult of subtraction \n```\n:::\n\n```{.r .cell-code}\nprint(result2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   -2   -1   -1\n[2,]    7   -5    2\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n**Practice**\n\n$$A= \\begin{bmatrix}\n1 & 4 & 2 \\\\\n-2 & -1 & 0 \\\\\n0 & -1 & 3\n\\end{bmatrix}$$\n\n$$B = \\begin{bmatrix}\n5 & 1 & 0 \\\\\n2 & -1 & 0 \\\\\n7 & 1 & 2\n\\end{bmatrix}$$\n\nCalculate $A+B$\n\n------------------------------------------------------------------------\n\n**Practice**\n\n$$A= \\begin{bmatrix}\n6 & -2 & 8 & 12 \\\\\n4 & 42 & 8 & -6 \\\\\n-14 & 5 & 0 & 0\n\\end{bmatrix}$$\n\n$$B = \\begin{bmatrix}\n18 & 42 & 3 & 7 \\\\\n0 & -42 & 15 & 4 \\\\\n-7 & 0 & 21 & -18\n\\end{bmatrix}$$\n\nCalculate $A-B$\n\n### Scalar multiplication\n\n-   Scalar multiplication is very intuitive.\n\n-   As we know, a scalar is a single number, or a 1 x 1 matrix.\n\n-   We multiply each value in the matrix by the scalar to perform this operation.\n\n-   This is expressed as follows: $$A = \n    \\begin{bmatrix}\n    a_{11} & a_{12} & a_{13}\\\\\n    a_{21} & a_{22} & a_{23}\\\\\n    a_{31} & a_{32} & a_{33}\n    \\end{bmatrix}$$ $$cA = \n    \\begin{bmatrix}\n    ca_{11} & ca_{12} & ca_{13}\\\\\n    ca_{21} & ca_{22} & ca_{23}\\\\\n    ca_{31} & ca_{32} & ca_{33}\n    \\end{bmatrix}$$\n\n#### Scalar multiplication in RStudio\n\n-   All we need to do is take an established matrix and multiply it by some scalar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    3   -1    2\n[2,]    9    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix1*3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    9   -3    6\n[2,]   27   12   18\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n**Practice** $$A= \\begin{bmatrix}\n    1 & 4 & 2 \\\\\n    8 & -1 & 3 \\\\\n    0 & -2 & 3\n    \\end{bmatrix}$$ $$ B = \\begin{bmatrix}\n    -15 & 1 & 5 \\\\\n    2 & -42 & 0 \\\\\n    7 & 1 & 6\n    \\end{bmatrix}$$\n\nCalculate $2\\times A$ and $-3 \\times B$\n\n### Matrix multiplication\n\n-   Two matrices must be *conformable* for them to be multiplied together.\n\n-   This means that the number of columns in the first matrix equals the number of rows in the second.\n\n-   When multiplying $A \\times B$, if $A$ is $m \\times n$, $B$ must have $n$ rows.\n\n::: callout-important\nThe conformability requirement *never* changes. Before multiplying anything, check to make sure the matrices are indeed conformable.\n:::\n\n-   The resulting matrix will have the same number of rows as the first matrix and the number of columns in the second.\n\n-   For example, if $A$ is $i \\times k$ and $B$ is $k \\times j$, then $A \\times B$ will be $i \\times j$.\n\n------------------------------------------------------------------------\n\nWhich of the following can we multiply? What will be the dimensions of the resulting matrix? $$\\begin{aligned}\nB=\n\\begin{bmatrix}\n2 \\\\\n3\\\\\n4\\\\\n1\n\\end{bmatrix}\nM = \n\\begin{bmatrix}\n1 & 0 & 2\\\\\n1 & 2 & 4\\\\\n2 & 3 & 2\n\\end{bmatrix}\nL = \n\\begin{bmatrix}\n6 & 5 & -1\\\\\n1 & 4 & 3 \n\\end{bmatrix}\n\\end{aligned}$$\n\n::: callout-warning\n## Warning\n\nWhen multiplying matrices, *order matters*.\n:::\n\n-   Why can't we multiply in the opposite order?\n\n### Multiplication steps\n\n-   Multiply each row by each column, summing up each pair of multiplied terms.\n\n::: callout-note\nThis is sometimes to referred to as the \"dot product,\" where we multiply matching members, then sum up.\n:::\n\n-   The element in position $ij$ is the sum of the products of elements in the $i$th row of the first matrix ($A$) and the corresponding elements in the $j$th column of the second matrix ($B$). $$c_{ij}=\\sum_{k=1}^n a_{ik}b_{kj}$$\n\n#### Example\n\n-   Suppose a company manufactures two kinds of furniture: chairs and sofas.\n\n    -   A chair costs \\$100 for wood, \\$270 for cloth, and \\$130 for feathers.\n\n    -   Each sofa costs \\$150 for wood, \\$420 for cloth, and \\$195 for feathers.\n\n|          | Chair | Sofa |\n|----------|-------|------|\n| Wood     | 100   | 150  |\n| Cloth    | 270   | 420  |\n| Feathers | 130   | 195  |\n\n-   The same information about unit cost ($C$) can be presented as a matrix.\n\n$$C = \\begin{bmatrix}\n100 & 150\\\\\n270 & 420\\\\\n130 & 195\n\\end{bmatrix}$$\n\n::: callout-note\nNote that each of the three rows of this 3 x 2 matrix represents a material (wood, cloth, or feathers), and each of the two columns represents a product (chair or coach). The elements are the unit cost (in USD).\n:::\n\n------------------------------------------------------------------------\n\n-   Now, suppose that the company will produce 45 chairs and 30 sofas this month.\n\n-   This production quantity can be represented in the following table, and also as a 2 x 1 matrix ($Q$).\n\n| Product | Quantity |\n|---------|----------|\n| Chair   | 45       |\n| Sofa    | 30       |\n\n$$Q = \\begin{bmatrix}\n45 \\\\\n30 \n\\end{bmatrix}$$\n\n-   The \"total expenditure\" is equal to the \"unit cost\" times the \"production quantity\" (the number of units).\n\n-   The total expenditure ($E$) for each material this month is calculated by multiplying these two matrices.\n\n$$\\begin{aligned} E = CQ =\n\\begin{bmatrix}\n100 & 150\\\\\n270 & 420\\\\\n130 & 195\n\\end{bmatrix}\n\\begin{bmatrix}\n45 \\\\\n30 \n\\end{bmatrix} =\n\\begin{bmatrix}\n(100)(45) + (150)(30) \\\\\n(270)(45) + (420)(30) \\\\\n(130)(45) + (195)(30)\n\\end{bmatrix} =\n\\begin{bmatrix}\n9,000 \\\\\n24,750 \\\\\n11,700\n\\end{bmatrix}\n\\end{aligned}$$\n\n-   Multiplying the 3 x 2 Cost matrix ($C$) times the 2 x 1 Quantity matrix ($Q$) yields the 3 x 1 Expenditure matrix ($E$).\n\n-   As a result of this matrix multiplication, we determine that this month the company will incur expenditures of:\n\n    -   \\$9,000 for wood\n    -   \\$24,750 for cloth\n    -   \\$11,700 for feathers.\n\n#### Matrix multiplication in RStudio\n\n-   We must make sure the matrices are conformable, as we do for our manual calculations.\n-   Then, we can multiply them together without issue.\n-   When multiplying together matrices in RStudio, remember to use the `%*%` operator, otherwise you will receive an error message.\n\n::: callout-warning\nIf you have a missing value or `NA` in one of the matrices you are trying to multiply, you will have NAs in your resulting matrix.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating matrices\nm <- matrix(1:8, nrow=2) # \nn <- matrix(8:15, nrow=4)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    8   12\n[2,]    9   13\n[3,]   10   14\n[4,]   11   15\n```\n:::\n\n```{.r .cell-code}\n# Multiplying matrices using operator\nm%*%n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]  162  226\n[2,]  200  280\n```\n:::\n:::\n\n\n## Properties\n\n-   Addition and subtraction:\n\n    -   Associative: $(A \\pm B) \\pm C = A \\pm (B \\pm C)$\n\n    -   Communicative: $A \\pm B = B \\pm A$\n\n-   Multiplication:\n\n    -   $AB \\neq BA$\n\n    -   $A(BC) = (AB)C$\n\n    -   $A(B+C) = AB + AC$\n\n    -   $(A+B)C = AC + BC$\n\n## Special matrices\n\nSquare matrix:\n\n-   The **diagonal** of a square matrix is a set of numbers consisting of the elements on the line from the upper-left-hand to the lower-right-hand corner of the matrix. Only a square matrix has a diagonal.\n\n-   The **trace** of a matrix is simply the sum of the diagonal elements of the matrix. So, then, a matrix must be square to have a trace.\n\nDiagonal matrix:\n\n-   In a **diagonal matrix**, all of the elements of the matrix that are not on the diagonal are equal to zero.\n\nScalar matrix:\n\n-   A **scalar matrix** is a diagonal matrix where the diagonal elements are all equal to each other. In other words, we're really only concerned with one scalar (or element) held in the diagonal.\n\nIdentity matrix:\n\n-   The **identity matrix** is a scalar matrix with all of the diagonal elements equal to one.\n\n-   All of the off-diagonal elements are equal to zero.\n\n-   The capital letter I is reserved for the identity matrix.\n\n## Transpose\n\n-   The transpose is the original matrix with the rows and the columns interchanged.\n\n-   The notation is either $J'$ (\"J prime\") or $J^T$ (\"J transpose\").\n\n$$J =\n\\begin{bmatrix}\n4 & 5\\\\\n3 & 0\\\\\n7 & -2\n\\end{bmatrix}$$\n\n$$J' = J^T = \n\\begin{bmatrix}\n4 & 3 & 7 \\\\\n5 & 0 & -2\n\\end{bmatrix}$$\n\n#### Transpose in RStudio\n\n-   We use `t()` to get the transpose.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Construct our matrix\nJ <- matrix(c(4,5,3,0,7,-2), nrow = 3, byrow = TRUE,)\nJ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    4    5\n[2,]    3    0\n[3,]    7   -2\n```\n:::\n\n```{.r .cell-code}\nt(J)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4    3    7\n[2,]    5    0   -2\n```\n:::\n:::\n\n\n## Inverse\n\n-   Just like a number has a reciprocal, a matrix has an inverse.\n\n-   When we multiply a matrix by its inverse we get the identity matrix (which is like \"1\" for matrices).\n\n$$A × A^{-1} = I$$\n\n-   The inverse of A is A-1 only when:\n\n$$AA^{-1} = A^{-1}A = I$$\n\n-   Sometimes there is no inverse at all.\n\n::: callout-note\nFor now, don't worry about calculating the inverse of a matrix manually. This is the type of task we use RStudio for.\n:::\n\n#### Examples\n\n-   We use the `solve()` function to calculate the inverse of a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create 3 different vectors\n# using combine method.\na1 <- c(3, 2, 5)\na2 <- c(2, 3, 2)\na3 <- c(5, 2, 4)\n  \n# bind the three vectors into a matrix \n# using rbind() which is basically\n# row-wise binding.\nA <- rbind(a1, a2, a3)\n  \n# print the original matrix\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3]\na1    3    2    5\na2    2    3    2\na3    5    2    4\n```\n:::\n\n```{.r .cell-code}\n# Use the solve() function to calculate the inverse.\nT1 <- solve(A)\n  \n# print the inverse of the matrix\nprint(T1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              a1          a2         a3\n[1,] -0.29629630 -0.07407407  0.4074074\n[2,] -0.07407407  0.48148148 -0.1481481\n[3,]  0.40740741 -0.14814815 -0.1851852\n```\n:::\n:::\n\n\n## Linear systems and matrices\n\n-   A system of equations can be represented by an *augmented matrix*.\n\n-   System of equations: $${\\color{red}{3}}x + {\\color{green}{6}}y = {\\color{blue}{12}}$$ $${\\color{red}{5}}x + {\\color{green}{10}}y = {\\color{blue}{25}}$$\n\n-   In an augmented matrix, each row represents one equation in the system and each column represents a variable or the constant terms. $$\\begin{bmatrix}\n    {\\color{red}{3}} & {\\color{green}{6}} & {\\color{blue}{12}}\\\\\n    {\\color{red}{5}} & {\\color{green}{10}} & {\\color{blue}{25}}\n    \\end{bmatrix}$$\n\n## OLS and matrices\n\n-   We can use the logic above to calculate estimates for our ordinary least squares (OLS) models.\n\n-   OLS is a linear regression technique used to find the best-fitting line for a set of data points (observations) by minimizing the residuals (the differences between the observed and predicted values).\n\n-   We minimize the *sum of the squared errors*.\n\n### Dependent variable\n\n-   Suppose, for example, we have a sample consisting of $n$ observations.\n\n-   The dependent variable is denoted as an $n \\times1$ column vector.\n\n$$Y = \\begin{bmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3 \\\\\n\\vdots \\\\\ny_n\n\\end{bmatrix}$$\n\n### Independent variables\n\n-   Suppose there are $k$ independent variables and a constant term, meaning $k+1$ columns and $n$ rows.\n\n-   We can represent these variables as an $n \\times (k+1)$ matrix, expressed as follows:\n\n$$X= \\begin{bmatrix}\n1 & x_{11} & \\dots & x_{1k} \\\\\n1 & x_{21} & \\dots & x_{2k} \\\\\n\\vdots & \\vdots & \\dots & \\vdots \\\\\n1 & x_{n1} & \\dots & x_{nk}\n\\end{bmatrix}$$\n\n-   $x_{ij}$ is the $i$-th observation of the $j$-th independent variable.\n\n### Linear regression model\n\n-   Let's say we have 173 observations (n = 173) and 2 IVs (k = 3).\n\n-   This can be expressed as the following linear equation: $$y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\epsilon$$\n\n-   In matrix form, we have: $$\\begin{aligned} \\begin{bmatrix}\n    y_1 \\\\\n    y_2 \\\\\n    \\vdots \\\\\n    y_n\n    \\end{bmatrix} = \\begin{bmatrix}\n    1 & x_{11} & x_{21} \\\\\n    1 & x_{21} & x_{22} \\\\\n    \\vdots & \\vdots & \\vdots \\\\\n    1 & x_{1173} & x_{2173} \n    \\end{bmatrix} \\begin{bmatrix}\n    \\beta_0 \\\\\n    \\beta_1 \\\\\n    \\beta_2 \n    \\end{bmatrix} + \\begin{bmatrix}\n    \\epsilon_1 \\\\\n    \\epsilon_2 \\\\\n    \\vdots \\\\\n    \\epsilon_{173}\n    \\end{bmatrix}\\end{aligned} $$\n\n-   All 173 equations can be represented by: $$y=X\\beta+\\epsilon$$\n\n### Estimates\n\n-   Without getting too much into the mechanics, we can calculate our coefficient estimates with matrix algebra using the following equation:\n\n$$\\hat{\\beta} = (X'X)^{-1}X'Y$$\n\n-   Read aloud, we say \"X prime X inverse, X prime Y\".\n\n-   The little hat on our beta ($\\hat{\\beta}$) signifies that these are estimates, that is our OLS estimators.\n\n-   Remember, the OLS method is to choose $\\hat{\\beta}$ such that the sum of squared residuals (\"SSR\") is minimized.\n\n#### Example in RStudio\n\n-   We will load the `mtcars` data set (our favorite) for this example, which contains data about many different car models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_df <- mtcars\n```\n:::\n\n\n-   Now, we want to estimate the association between `hp` (horsepower) and `wt` (weight), our independent variables, and `mpg` (miles per gallon), our dependent variable.\n\n-   First, we transform our dependent variable into a matrix, using the `as.matrix` function and specifying the column of the `mtcars` data set to create a column vector of our observed values for the DV.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nY <- as.matrix(cars_df[,1])\nY\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,] 21.0\n [2,] 21.0\n [3,] 22.8\n [4,] 21.4\n [5,] 18.7\n [6,] 18.1\n [7,] 14.3\n [8,] 24.4\n [9,] 22.8\n[10,] 19.2\n[11,] 17.8\n[12,] 16.4\n[13,] 17.3\n[14,] 15.2\n[15,] 10.4\n[16,] 10.4\n[17,] 14.7\n[18,] 32.4\n[19,] 30.4\n[20,] 33.9\n[21,] 21.5\n[22,] 15.5\n[23,] 15.2\n[24,] 13.3\n[25,] 19.2\n[26,] 27.3\n[27,] 26.0\n[28,] 30.4\n[29,] 15.8\n[30,] 19.7\n[31,] 15.0\n[32,] 21.4\n```\n:::\n:::\n\n\n-   Next, we do the same thing for our independent variables of interest, and our constant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create two separate matrices for IVs\nX1 <- as.matrix(cars_df[,4])\nX2 <- as.matrix(cars_df[,6])\n\n# create constant column\n\n# bind them altogether into one matrix\nconstant <-  rep(1,nrow(X1))\nX <- cbind(constant,X1,X2)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      constant          \n [1,]        1 110 2.620\n [2,]        1 110 2.875\n [3,]        1  93 2.320\n [4,]        1 110 3.215\n [5,]        1 175 3.440\n [6,]        1 105 3.460\n [7,]        1 245 3.570\n [8,]        1  62 3.190\n [9,]        1  95 3.150\n[10,]        1 123 3.440\n[11,]        1 123 3.440\n[12,]        1 180 4.070\n[13,]        1 180 3.730\n[14,]        1 180 3.780\n[15,]        1 205 5.250\n[16,]        1 215 5.424\n[17,]        1 230 5.345\n[18,]        1  66 2.200\n[19,]        1  52 1.615\n[20,]        1  65 1.835\n[21,]        1  97 2.465\n[22,]        1 150 3.520\n[23,]        1 150 3.435\n[24,]        1 245 3.840\n[25,]        1 175 3.845\n[26,]        1  66 1.935\n[27,]        1  91 2.140\n[28,]        1 113 1.513\n[29,]        1 264 3.170\n[30,]        1 175 2.770\n[31,]        1 335 3.570\n[32,]        1 109 2.780\n```\n:::\n:::\n\n\n-   Next, we calculate $X'X$, $X'Y$, and $(X'X)^{-1}$.\n\n::: callout-reminder\nDon't forget to use `%*%` for matrix multiplication!\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# X prime X\nXpX <- t(X)%*%X\n\n# X prime X inverse\nXpXinv <- solve(XpX)\n\n# X prime Y\nXpY <- t(X)%*%Y\n\n# beta coefficient estimates\nbhat <- XpXinv %*% XpY\nbhat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                [,1]\nconstant 37.22727012\n         -0.03177295\n         -3.87783074\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}