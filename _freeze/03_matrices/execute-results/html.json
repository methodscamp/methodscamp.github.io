{
  "hash": "38f1490c6a71829bd340847647a4fb35",
  "result": {
    "markdown": "# Matrices\n\n## Introduction\n\n### Scalars\n\n-   One number (for example, 12) is referred to as a scalar.\n\n-   Each scalar in a matrix is an *element* of that matrix.\n\n$$\\begin{bmatrix}\n12\n\\end{bmatrix}$$\n\n::: callout-note\nThis is also called a 1 x 1 (\"one by one\") matrix.\n:::\n\n### Vectors\n\n-   We can put several scalars together to make a vector.\n\n-   Here is an example: $$\\begin{bmatrix}\n        12 \\\\\n        14 \\\\\n        15\n        \\end{bmatrix}\n        = b$$\n\n-   Since this is a column of numbers, we cleverly refer to it as a *column vector*.\n\n-   Here is another example of a vector: $$\\begin{bmatrix}\n    12 & 14 & 15\n    \\end{bmatrix}\n    = d$$\n\n-   This, in contrast, is called a *row vector*.\n\n#### Vector construction in RStudio\n\n-   Vectors are very easy to construct in RStudio.\n-   Here are two examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making a simple column vector\ncol_vector <- matrix(1:12)\ncol_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n[11,]   11\n[12,]   12\n```\n:::\n\n```{.r .cell-code}\n# Making a simple row vector\nrow_vector <- 15:23\nrow_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15 16 17 18 19 20 21 22 23\n```\n:::\n:::\n\n\n## Operators\n\n### Summation\n\n-   The summation operator $\\sum$ lets us perform an operation on a sequence of numbers, which is often but not always a vector.\n\n$$x = \\begin{bmatrix}\n12 & 7 & -2 & 0 & 1\n\\end{bmatrix}$$\n\n-   We can then calculate the sum of the first three elements of the vector, which is expressed as follows: $$\\sum_{i=1}^3 x_i$$\n\n-   Then, we do the following math: $$12+7+(-2)=17$$\n\n### Product\n\n-   The product operator $\\prod$ can also perform operations over a sequence of elements in a vector.\n\n$$z = \\begin{bmatrix}\n5 & -3 & 5 & 1\n\\end{bmatrix}$$\n\n-   We can then calculate the calculate the product of the four elements in the vector, which is expressed as follows: $$\\prod_{i=1}^4 z_i$$\n\n-   Then, we do the following math: $$5 \\times -3 \\times 5 \\times 1=-75$$ \\## Matrices\n\n#### Operators in RStudio\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summation\nmat <- c(5,-3,5,1)\nsum(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n# Product\nprod(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -75\n```\n:::\n:::\n\n\n### Basics\n\n-   We can append vectors together to form a matrix:\n\n$$\\begin{bmatrix}\n12 & 14 & 15 \\\\\n115 & 22 & 127 \\\\\n193 & 29 & 219\n\\end{bmatrix}\n= A$$\n\n-   The number of rows and columns of a matrix constitute the dimensions of the matrix.\n\n-   The first number is the number of rows (\"r\") and the second number is the number of columns (\"c\") in the matrix.\n\n::: callout-important\nFind a way to remember \"r x c\" *permanently*. The order of the dimensions never changes.\n:::\n\n-   Matrix $A$ above, for example, is a $3x3$ matrix.\n\n-   We often use capital letters (sometimes **bold-faced**) to represent matrices.\n\n#### Appending in RStudio\n\n-   We use `rbind()` to create a matrix, in which each vector will be a row.\n-   If we use `cbind()`, then each vector will be a column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create some vectors\nvec_1 <- 1:4\nvec_2 <- 5:8\nvec_3 <- 9:12\nvec_4 <- 13:16\n\n# rbind\nrbind_mat <- rbind(vec_1, vec_2, vec_3, vec_4)\nrbind_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4]\nvec_1    1    2    3    4\nvec_2    5    6    7    8\nvec_3    9   10   11   12\nvec_4   13   14   15   16\n```\n:::\n\n```{.r .cell-code}\n# cbind\ncbind_mat <- cbind(vec_1, vec_2, vec_3, vec_4)\ncbind_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     vec_1 vec_2 vec_3 vec_4\n[1,]     1     5     9    13\n[2,]     2     6    10    14\n[3,]     3     7    11    15\n[4,]     4     8    12    16\n```\n:::\n:::\n\n\n### Structure\n\n-   How do we refer to specific elements of the matrix?\n\n-   Matrix $A$ is an $m\\times n$ matrix where $m=n=3$\n\n-   More generally, matrix $B$ is an $m\\times n$ matrix where the elements look like this: $$B=\n    \\begin{bmatrix}\n    b_{11} & b_{12} & b_{13} & \\ldots & b_{1n} \\\\\n    b_{21} & b_{22} & b_{23} & \\ldots & b_{2n} \\\\\n    \\vdots & \\vdots & \\vdots & \\ldots & \\vdots \\\\\n    b_{m1} & b_{m2} & b_{m3} & \\ldots & b_{mn}\n    \\end{bmatrix}$$\n\n-   Thus $b_{23}$ refers to the second unit down and third across.\n\n::: callout-tip\n## Reminder\n\nWhen trying to identify a specific element, the first subscript is the element's row and the second subscript is the element's column (*always* in that order).\n:::\n\n#### Constructing matrices in RStudio\n\n-   Matrices are very easy to construct in RStudio.\n-   The basic syntax is `matrix(data, nrow, ncol, byrow, dimnames)`.\n    -   `data` is the input vector which becomes the data elements of the matrix.\n    -   `nrow` is the number of rows to be created.\n    -   `ncol` is the number of columns to be created.\n    -   `byrow` is a logical clue. If TRUE then the input vector elements are arranged by row.\n    -   `dimname` is the names assigned to the rows and columns.\n-   Here are some examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Elements are arranged sequentially by row.\nM <- matrix(c(1:12), nrow = 4, byrow = TRUE)\nprint(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n```\n:::\n\n```{.r .cell-code}\n# Elements are arranged sequentially by column.\nN <- matrix(c(1:12), nrow = 4, byrow = FALSE)\nprint(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n:::\n\n```{.r .cell-code}\n# Define the column and row names.\nrownames = c(\"row1\", \"row2\", \"row3\", \"row4\")\ncolnames = c(\"col1\", \"col2\", \"col3\")\n\nP <- matrix(c(1:12), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))\n\nprint(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3\nrow1    1    2    3\nrow2    4    5    6\nrow3    7    8    9\nrow4   10   11   12\n```\n:::\n\n```{.r .cell-code}\n# Access the element at 1st row and 3rd column.\nprint(P[1,3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n# Access the element at 4th row and 2nd column.\nprint(P[4,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\n## Matrix operations\n\n### Addition and subtraction\n\n-   Addition and subtraction are straightforward operations.\n\n-   Matrices must have *exactly* the same dimensions for both of these operations.\n\n-   We add or subtract each element with the corresponding element from the other matrix.\n\n-   This is expressed as follows:\n\n$$A \\pm B=C$$\n\n$$c_{ij}=a_{ij} \\pm b_{ij} \\text{ }\\forall i,j$$\n\n$$\\begin{bmatrix}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\\\\\na_{31} & a_{32} & a_{33}\n\\end{bmatrix}\n\\pm\n\\begin{bmatrix}\nb_{11} & b_{12} & b_{13}\\\\\nb_{21} & b_{22} & b_{23}\\\\\nb_{31} & b_{32} & b_{33}\n\\end{bmatrix}$$ $$=$$ $$\\begin{bmatrix}\na_{11}\\pm b_{11} & a_{12}\\pm b_{12} & a_{13}\\pm b_{13}\\\\\na_{21}\\pm b_{21} & a_{22}\\pm b_{22} & a_{23}\\pm b_{23}\\\\\na_{31}\\pm b_{31} & a_{32}\\pm b_{32} & a_{33}\\pm b_{33}\n\\end{bmatrix}$$\n\n#### Add and subtract in RStudio\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create two 2x3 matrices.\nmatrix1 <- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)\nprint(matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    3   -1    2\n[2,]    9    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix2 <- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)\nprint(matrix2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    0    3\n[2,]    2    9    4\n```\n:::\n\n```{.r .cell-code}\n# Add the matrices.\nresult1 <- matrix1 + matrix2\ncat(\"Result of addition\",\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResult of addition \n```\n:::\n\n```{.r .cell-code}\nprint(result1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    8   -1    5\n[2,]   11   13   10\n```\n:::\n\n```{.r .cell-code}\n# Subtract the matrices\nresult2 <- matrix1 - matrix2\ncat(\"Result of subtraction\",\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResult of subtraction \n```\n:::\n\n```{.r .cell-code}\nprint(result2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   -2   -1   -1\n[2,]    7   -5    2\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n**Practice**\n\n$$A= \\begin{bmatrix}\n1 & 4 & 2 \\\\\n-2 & -1 & 0 \\\\\n0 & -1 & 3\n\\end{bmatrix}$$\n\n$$B = \\begin{bmatrix}\n5 & 1 & 0 \\\\\n2 & -1 & 0 \\\\\n7 & 1 & 2\n\\end{bmatrix}$$\n\nCalculate $A+B$\n\n------------------------------------------------------------------------\n\n**Practice**\n\n$$A= \\begin{bmatrix}\n6 & -2 & 8 & 12 \\\\\n4 & 42 & 8 & -6 \\\\\n-14 & 5 & 0 & 0\n\\end{bmatrix}$$\n\n$$B = \\begin{bmatrix}\n18 & 42 & 3 & 7 \\\\\n0 & -42 & 15 & 4 \\\\\n-7 & 0 & 21 & -18\n\\end{bmatrix}$$\n\nCalculate $A-B$\n\n### Scalar multiplication\n\n-   Scalar multiplication is very intuitive.\n\n-   As we know, a scalar is a single number, or a 1 x 1 matrix.\n\n-   We multiply each value in the matrix by the scalar to perform this operation.\n\n-   This is expressed as follows: $$A = \n    \\begin{bmatrix}\n    a_{11} & a_{12} & a_{13}\\\\\n    a_{21} & a_{22} & a_{23}\\\\\n    a_{31} & a_{32} & a_{33}\n    \\end{bmatrix}$$ $$cA = \n    \\begin{bmatrix}\n    ca_{11} & ca_{12} & ca_{13}\\\\\n    ca_{21} & ca_{22} & ca_{23}\\\\\n    ca_{31} & ca_{32} & ca_{33}\n    \\end{bmatrix}$$\n    \n#### Scalar multiplication in RStudio\n\n-    All we need to do is take an established matrix and multiply it by some scalar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    3   -1    2\n[2,]    9    4    6\n```\n:::\n\n```{.r .cell-code}\nmatrix1*3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    9   -3    6\n[2,]   27   12   18\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n**Practice** $$A= \\begin{bmatrix}\n    1 & 4 & 2 \\\\\n    8 & -1 & 3 \\\\\n    0 & -2 & 3\n    \\end{bmatrix}$$ $$ B = \\begin{bmatrix}\n    -15 & 1 & 5 \\\\\n    2 & -42 & 0 \\\\\n    7 & 1 & 6\n    \\end{bmatrix}$$\n\nCalculate $2\\times A$ and $-3 \\times B$\n\n### Matrix multiplication\n\n-   Two matrices must be *conformable* for them to be multiplied together.\n\n-   This means that the number of columns in the first matrix equals the number of rows in the second.\n\n-   When multiplying $A \\times B$, if $A$ is $m \\times n$, $B$ must have $n$ rows.\n\n::: callout-important\nThe conformability requirement *never* changes. Before multiplying anything, check to make sure the matrices are indeed conformable.\n:::\n\n-   The resulting matrix will have the same number of rows as the first matrix and the number of columns in the second.\n\n-   For example, if $A$ is $i \\times k$ and $B$ is $k \\times j$, then $A \\times B$ will be $i \\times j$.\n\n------------------------------------------------------------------------\n\nWhich of the following can we multiply? What will be the dimensions of the resulting matrix? $$\\begin{aligned}\nB=\n\\begin{bmatrix}\n2 \\\\\n3\\\\\n4\\\\\n1\n\\end{bmatrix}\nM = \n\\begin{bmatrix}\n1 & 0 & 2\\\\\n1 & 2 & 4\\\\\n2 & 3 & 2\n\\end{bmatrix}\nL = \n\\begin{bmatrix}\n6 & 5 & -1\\\\\n1 & 4 & 3 \n\\end{bmatrix}\n\\end{aligned}$$\n\n::: callout-warning\n## Warning\n\nWhen multiplying matrices, *order matters*.\n:::\n\n-   Why can't we multiply in the opposite order?\n\n### Multiplication steps\n\n-   Multiply each row by each column, summing up each pair of multiplied terms.\n\n::: callout-note\nThis is sometimes to referred to as the \"dot product,\" where we multiply matching members, then sum up.\n:::\n\n-   The element in position $ij$ is the sum of the products of elements in the $i$th row of the first matrix ($A$) and the corresponding elements in the $j$th column of the second matrix ($B$). $$c_{ij}=\\sum_{k=1}^n a_{ik}b_{kj}$$\n\n#### Example\n\n-   Suppose a company manufactures two kinds of furniture: chairs and sofas.\n\n    -   A chair costs \\$100 for wood, \\$270 for cloth, and \\$130 for feathers.\n\n    -   Each sofa costs \\$150 for wood, \\$420 for cloth, and \\$195 for feathers.\n\n|          | Chair | Sofa |\n|----------|-------|------|\n| Wood     | 100   | 150  |\n| Cloth    | 270   | 420  |\n| Feathers | 130   | 195  |\n\n-   The same information about unit cost ($C$) can be presented as a matrix.\n\n$$C = \\begin{bmatrix}\n100 & 150\\\\\n270 & 420\\\\\n130 & 195\n\\end{bmatrix}$$\n\n::: callout-note\nNote that each of the three rows of this 3 x 2 matrix represents a material (wood, cloth, or feathers), and each of the two columns represents a product (chair or coach). The elements are the unit cost (in USD).\n:::\n\n------------------------------------------------------------------------\n\n-   Now, suppose that the company will produce 45 chairs and 30 sofas this month.\n\n-   This production quantity can be represented in the following table, and also as a 2 x 1 matrix ($Q$).\n\n| Product | Quantity |\n|---------|----------|\n| Chair   | 45       |\n| Sofa    | 30       |\n\n$$Q = \\begin{bmatrix}\n45 \\\\\n30 \n\\end{bmatrix}$$\n\n-   The \"total expenditure\" is equal to the \"unit cost\" times the \"production quantity\" (the number of units).\n\n-   The total expenditure ($E$) for each material this month is calculated by multiplying these two matrices.\n\n$$\\begin{aligned} E = CQ =\n\\begin{bmatrix}\n100 & 150\\\\\n270 & 420\\\\\n130 & 195\n\\end{bmatrix}\n\\begin{bmatrix}\n45 \\\\\n30 \n\\end{bmatrix} =\n\\begin{bmatrix}\n(100)(45) + (150)(30) \\\\\n(270)(45) + (420)(30) \\\\\n(130)(45) + (195)(30)\n\\end{bmatrix} =\n\\begin{bmatrix}\n9,000 \\\\\n24,750 \\\\\n11,700\n\\end{bmatrix}\n\\end{aligned}$$\n\n-   Multiplying the 3 x 2 Cost matrix ($C$) times the 2 x 1 Quantity matrix ($Q$) yields the 3 x 1 Expenditure matrix ($E$).\n\n-   As a result of this matrix multiplication, we determine that this month the company will incur expenditures of:\n\n    -   \\$9,000 for wood\n    -   \\$24,750 for cloth\n    -   \\$11,700 for feathers.\n    \n#### Matrix multiplication in RStudio\n\n-    We must make sure the matrices are conformable, as we do for our manual calculations.\n-   Then, we can multiply them together without issue.\n-   When multiplying together matrices in RStudio, remember to use the `%*%` operator, otherwise you will receive an error message.\n\n::: callout-warning\nIf you have a missing value or `NA` in one of the matrices you are trying to multiply, you will have NAs in your resulting matrix.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating matrices\nm <- matrix(1:8, nrow=2) # \nn <- matrix(8:15, nrow=4)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    8   12\n[2,]    9   13\n[3,]   10   14\n[4,]   11   15\n```\n:::\n\n```{.r .cell-code}\n# Multiplying matrices using operator\nm%*%n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]  162  226\n[2,]  200  280\n```\n:::\n:::\n\n\n## Properties\n\n-   Addition and subtraction:\n\n    -   Associative: $(A \\pm B) \\pm C = A \\pm (B \\pm C)$\n\n    -   Communicative: $A \\pm B = B \\pm A$\n\n-   Multiplication:\n\n    -   $AB \\neq BA$\n\n    -   $A(BC) = (AB)C$\n\n    -   $A(B+C) = AB + AC$\n\n    -   $(A+B)C = AC + BC$\n\n## Special matrices\n\nSquare matrix:\n\n-   The **diagonal** of a square matrix is a set of numbers consisting of the elements on the line from the upper-left-hand to the lower-right-hand corner of the matrix. Only a square matrix has a diagonal.\n\n-   The **trace** of a matrix is simply the sum of the diagonal elements of the matrix. So, then, a matrix must be square to have a trace.\n\nDiagonal matrix:\n\n-   In a **diagonal matrix**, all of the elements of the matrix that are not on the diagonal are equal to zero.\n\nScalar matrix:\n\n-   A **scalar matrix** is a diagonal matrix where the diagonal elements are all equal to each other. In other words, we're really only concerned with one scalar (or element) held in the diagonal.\n\nIdentity matrix:\n\n-   The **identity matrix** is a scalar matrix with all of the diagonal elements equal to one.\n\n-   All of the off-diagonal elements are equal to zero.\n\n-   The capital letter I is reserved for the identity matrix.\n\n## Transpose\n\n-   The transpose is the original matrix with the rows and the columns interchanged.\n\n-   The notation is either $J'$ (\"J prime\") or $J^T$ (\"J transpose\").\n\n$$J =\n\\begin{bmatrix}\n4 & 5\\\\\n3 & 0\\\\\n7 & -2\n\\end{bmatrix}$$\n\n$$J' = J^T = \n\\begin{bmatrix}\n4 & 3 & 7 \\\\\n5 & 0 & -2\n\\end{bmatrix}$$\n\n#### Transpose in RStudio\n\n-   We use `t()` to get the transpose.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Construct our matrix\nJ <- matrix(c(4,5,3,0,7,-2), nrow = 3, byrow = TRUE,)\nJ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    4    5\n[2,]    3    0\n[3,]    7   -2\n```\n:::\n\n```{.r .cell-code}\nt(J)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4    3    7\n[2,]    5    0   -2\n```\n:::\n:::\n\n\n## Inverse\n\n-   Just like a number has a reciprocal, a matrix has an inverse.\n\n-   When we multiply a matrix by its inverse we get the identity matrix (which is like \"1\" for matrices).\n\n$$A × A^{-1} = I$$\n\n-   The inverse of A is A-1 only when:\n\n$$AA^{-1} = A^{-1}A = I$$\n\n-   Sometimes there is no inverse at all.\n\n::: callout-note\nFor now, don't worry about calculating the inverse of a matrix manually. This is the type of task we use RStudio for.\n:::\n\n#### Examples\n\n-   We use the `solve()` function to calculate the inverse of a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create 3 different vectors\n# using combine method.\na1 <- c(3, 2, 5)\na2 <- c(2, 3, 2)\na3 <- c(5, 2, 4)\n  \n# bind the three vectors into a matrix \n# using rbind() which is basically\n# row-wise binding.\nA <- rbind(a1, a2, a3)\n  \n# print the original matrix\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3]\na1    3    2    5\na2    2    3    2\na3    5    2    4\n```\n:::\n\n```{.r .cell-code}\n# Use the solve() function to calculate the inverse.\nT1 <- solve(A)\n  \n# print the inverse of the matrix\nprint(T1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              a1          a2         a3\n[1,] -0.29629630 -0.07407407  0.4074074\n[2,] -0.07407407  0.48148148 -0.1481481\n[3,]  0.40740741 -0.14814815 -0.1851852\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}