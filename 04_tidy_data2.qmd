# Tidy data analysis II

In this session, we'll cover a few more advanced topics related to data wrangling. Again we'll use the `tidyverse`:

```{r}
library(tidyverse)
```

## Loading data in different formats.

In this module we will use cross-national data from the [Quality of Government (QoG) project](https://www.gu.se/en/quality-government/qog-data/data-downloads/basic-dataset) ([Dahlberg et al., 2023](https://www.gu.se/en/quality-government%20doi:10.18157/qogbasjan23)).

Notice how in the `data/` folder we have multiple versions of the same dataset (a subset of the QOG basic dataset): .csv (comma-separated values), .rds (R), .xlsx (Excel), .dta (Stata), and .sav (SPSS).

### CSV and R data files

We can use the `read_csv()` and `read_rds()` functions from the `tidyverse`[^04_tidy_data2-1] to read the .csv and .rds (R) data files:

[^04_tidy_data2-1]: Technically, the `read_csv()` and `read_rds()` functions come from `readr`, one of the `tidyverse` constituent packages.

```{r}
qog_csv <- read_csv("data/sample_qog_bas_ts_jan23.csv")
```

```{r}
qog_rds <- read_rds("data/sample_qog_bas_ts_jan23.rds")
```

For reading files from other software (Excel, Stata, or SPSS), we need to load additional packages. Luckily, they are automatically installed when one installs the `tidyverse`.

### Excel data files

For Excel files (.xls or .xlsx files), the `readxl` package has a handy `read_excel()` function.

```{r}
library(readxl)
qog_excel <- read_excel("data/sample_qog_bas_ts_jan23.xlsx")
```

::: callout-tip
Useful arguments of the `read_excel()` function include `sheet =`, which reads particular sheets (specified via their positions or sheet names), and `range =`, which extracts a particular cell range (e.g., \`A5:E25\`).
:::

### Stata and SPSS data files

To load files from Stata (.dta) or SPSS (.spss), one needs the `haven` package and its properly-named `read_stata()` and `read_spss()` functions:

```{r}
library(haven)
qog_stata <- read_stata("data/sample_qog_bas_ts_jan23.dta")
qog_spss <- read_spss("data/sample_qog_bas_ts_jan23.sav")
```

::: callout-tip
Datasets from Stata and SPSS can have additional properties, like variable labels and special types of missing values. To learn more about this, check out the ["Labelled data" chapter](https://socialresearchcentre.github.io/r_survey_datasets/labelled-data.html) from Danny Smith's *Survey Research Datasets and R* [(2020)](https://socialresearchcentre.github.io/r_survey_datasets/).
:::

### Our data for this session

We will rename one of our objects to `qog`:

```{r}
qog <- qog_csv
qog
```

This dataset is a small sample of QOG, which contains data for countries in the Americas from 1990 to 2020. The observational unit is thus country-year. You can access the [full codebook](https://www.qogdata.pol.gu.se/data/codebook_bas_jan23.pdf) online. The variables are as follows:

| Variable         | Description                                                   |
|--------------------|----------------------------------------------------|
| `cname`          | Country name                                                  |
| `ccodealp`       | Country code (ISO-3 character convention)                     |
| `year`           | Year                                                          |
| `region`         | Region (following legacy WDI convention). Added to QOG by us. |
| `wdi_pop`        | Total population, from the World Development Indicators       |
| `vdem_polyarchy` | V-Dem's polyarchy index (electoral democracy)                 |
| `vdem_corr`      | V-Dem's corruption index                                      |
| `ht_colonial`    | Former colonial ruler                                         |

## Recoding variables

Take a look at the `ht_colonial` variable. We can do a simple tabulation with `count()`:

```{r}
qog |> 
  count(ht_colonial)
```

We might want to recode this variable. For instance, we could create a *dummy*/*binary* variable for whether the country was a British colony. We can do this with `if_else()`, which works with logical conditions:

```{r}
qog |> 
  # the arguments are condition, true (what to do if true), false
  mutate(d_britishcol = if_else(ht_colonial == "British", 1, 0)) |> 
  count(d_britishcol)
```

Instead of a numeric classification (0 and 1), we could use characters:

```{r}
qog |> 
  mutate(cat_britishcol = if_else(ht_colonial == "British", "British", "Other")) |> 
  count(cat_britishcol)
```

`if_else()` is great for binary recoding. But sometimes we want to create more than two categories. We can use `case_when()`:

```{r}
qog |> 
  # syntax is condition ~ value
  mutate(cat_col = case_when(
    ht_colonial == "British" ~ "British",
    ht_colonial == "Spanish" ~ "Spanish", 
    .default = "Other" # what to do in all other cases
  )) |> 
  count(cat_col)
```

The `.default =` argument in `case_when()` can also be used to leave the variable as-is for non-specified cases. For example, let's combine Portuguese and Spanish colonies:

```{r}
qog |> 
  # syntax is condition ~ value
  mutate(cat_col = case_when(
    ht_colonial %in% c("Spanish", "Portuguese") ~ "Spanish/Portuguese",
    .default = ht_colonial # what to do in all other cases
  )) |> 
  count(cat_col)
```

::: callout-note

#### Exercise

1.  Create a dummy variable, `d_large_pop`, for whether the country-year has a population of more than 1 million. Then compute its mean. Your code:

2.  Which countries are recorded as "Never colonized"? Change their values to other reasonable codings and compute a tabulation with `count()`. Your code:

:::

## Missing values

Missing values are commonplace in real datasets. In R, missing values are a special type of value in vectors, denoted as `NA`.

::: callout-warning

The special value `NA` is different from the character value "NA". For example, notice that a numeric vector can have `NAs`, while it obviously cannot hold the character value "NA":

```{r}
c(5, 4.6, NA, 8)
```

:::

A quick way to check for missing values in small datasets is with the `summary()` function:

```{r}
summary(qog)
```

Notice that we have missingness in the `vdem_polyarchy` and `vdem_corr` variables. We might want to filter the dataset to see which observations are in this situation:

```{r}
qog |> 
  filter(vdem_polyarchy == NA | vdem_corr == NA)
```

But the code above doesn't work! To refer to missing values in logical conditions, we cannot use `== NA`. Instead, we need to use the `is.na()` function:

```{r}
qog |> 
  filter(is.na(vdem_polyarchy) | is.na(vdem_corr))
```

Notice that, in most R functions, missing values are "contagious." This means that any missing value will "contamine" the results and carry over. For example:

```{r}
qog |> 
  summarize(mean_vdem_polyarchy = mean(vdem_polyarchy))
```

Sometimes we'd like to perform our operations even in the presence of missing values, simply excluding them. Most basic R functions have an `na.rm =` argument to do this:

```{r}
qog |> 
  summarize(mean_vdem_polyarchy = mean(vdem_polyarchy, na.rm = T))
```

::: callout-note

#### Exercise

Calculate the median value of the corruption variable for each region (i.e., perform a grouped summary). Your code:



:::

## Pivoting data

TODO.
